"""
This type stub file was generated by pyright.
"""

__all__ = ("Pagination", "ListFieldPagination")
class Pagination:
    def __init__(self, iterable, page, per_page) -> None:
        ...
    
    @property
    def pages(self): # -> int:
        """The total number of pages"""
        ...
    
    def prev(self, error_out=...): # -> Self:
        """Returns a :class:`Pagination` object for the previous page."""
        ...
    
    @property
    def prev_num(self):
        """Number of the previous page."""
        ...
    
    @property
    def has_prev(self):
        """True if a previous page exists"""
        ...
    
    def next(self, error_out=...): # -> Self:
        """Returns a :class:`Pagination` object for the next page."""
        ...
    
    @property
    def has_next(self):
        """True if a next page exists."""
        ...
    
    @property
    def next_num(self):
        """Number of the next page"""
        ...
    
    def iter_pages(self, left_edge=..., left_current=..., right_current=..., right_edge=...): # -> Generator[int | None, Any, None]:
        """Iterates over the page numbers in the pagination.  The four
        parameters control the thresholds how many numbers should be produced
        from the sides.  Skipped page numbers are represented as `None`.
        This is how you could render such a pagination in the templates:

        .. sourcecode:: html+jinja

            {% macro render_pagination(pagination, endpoint) %}
              <div class=pagination>
              {%- for page in pagination.iter_pages() %}
                {% if page %}
                  {% if page != pagination.page %}
                    <a href="{{ url_for(endpoint, page=page) }}">{{ page }}</a>
                  {% else %}
                    <strong>{{ page }}</strong>
                  {% endif %}
                {% else %}
                  <span class=ellipsis>â€¦</span>
                {% endif %}
              {%- endfor %}
              </div>
            {% endmacro %}
        """
        ...
    


class ListFieldPagination(Pagination):
    def __init__(self, queryset, doc_id, field_name, page, per_page, total=...) -> None:
        """Allows an array within a document to be paginated.

        Queryset must contain the document which has the array we're
        paginating, and doc_id should be it's _id.
        Field name is the name of the array we're paginating.
        Page and per_page work just like in Pagination.
        Total is an argument because it can be computed more efficiently
        elsewhere, but we still use array.length as a fallback.
        """
        ...
    
    def prev(self, error_out=...): # -> Self:
        """Returns a :class:`Pagination` object for the previous page."""
        ...
    
    def next(self, error_out=...): # -> Self:
        """Returns a :class:`Pagination` object for the next page."""
        ...
    


